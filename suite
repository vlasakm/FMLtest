#!/bin/bash

# Make empty globs not expand to the glob string
shopt -s nullglob

COLOR=true # or false

# How wide the test name is allowed to be (just aesthetics)
TEXT_WIDTH=74

# Locate this script on disk to use as root.
ROOT_DIR=$(dirname $(readlink -f "$0"))

# Where the tests are
INPUT_DIR="$ROOT_DIR/tests"

# Where all output is saved to
OUTPUT_DIR="$ROOT_DIR/output"

function die {
	echo "$0: error: $@" >&2
	exit 1
}

# Some basics
function is_defined {
    [ -z $1 ] && echo false || echo true
}
function with_default {
    case $# in
    0) echo -n "";;
    1) echo -n "$1";;
    2) $(is_defined "$1") && echo -n "$1" || echo -n "$2";;
    *) die "with_default accepts 2 arguments, but $# were given" ;;
    esac
}
function print_justified {
    message="$@"
    printf "%-${TEXT_WIDTH}s" "$message"
}
function print_green {
    if $COLOR
    then echo -e "\e[32m$@\e[0m"
    else echo "$@"
    fi
}
function print_red {
    if $COLOR
    then echo -e "\e[31m$@\e[0m"
    else echo "$@"
    fi
}
function compare_against_template {
    template="$1"
    encountered="$2"
    expected="$3"
    output="$4"

    # Extract the relevant comments from the source file to get expected output
    sed -n 's/[^/]*\/\/ > \(.*\)/\1/p' "$template" > "$expected"

    # Compare output and expected output
    diff "$expected" "$encountered" > "$output"

    # Return result of comparison
    return $?
}

function ast_interpret {
    "$fml" run_ast "$input" 1> "$output" 2>/dev/null
}

function bc_interpret {
    template="$in.bc.txt"
    "$fml" execute "$input" > "$output" 2>/dev/null
}

function bc_compile {
    ast="$out.ast.json"
    compiled_bytecode="$out.bc"

    "$fml" compile "$input" > "$compiled_bytecode" 2>/dev/null && \
    "$fml_ref_bc_int" execute "$compiled_bytecode" 2>/dev/null 1> "$output"
}

function run_test {
    format=$1 # "fml" or "bc"
    type=$2   # e.g. "run_ast"
    test=${3%%.*} # e.g. "arrays" or "arrays.fml" or "arrays.bc.txt"

    # Create dir or die
    mkdir -p "$OUTPUT_DIR/$type/" || die "failed to create output dir"

    in="$INPUT_DIR/$format/$test"
    out="$OUTPUT_DIR/$type/$test"
    input="$in.$format"
    output="$out.out"
    expected="$out.expected"
    delta="$out.diff"
    template="$input"

    [[ -r "$input" ]] || die "Can't read '$input'"

    # Report in
    print_justified "Executing $type test: \"$test\"... "

    # Run the test function
    "$type"
    exit_code=$?

    # Compare results, print delta into a file, and report
    if (( $exit_code == 0 )) && compare_against_template "$template" "$output" "$expected" "$delta"
    then print_green "passed"
    else print_red   "failed\n[exit code $exit_code, details: \"$delta\"]\n"
    fi
}

function get_extension {
    case "$1" in
        ast_interpret) extension=fml ;;
        bc_interpret) extension=bc ;;
        bc_compile) extension=fml ;;
        *) die "Unknown test type '$1'. Available test types: ast_interpret, bc_interpret, bc_compile." ;;
    esac
}

function get_tests {
    extension="$1"
    # Read tests in directory with glob into array
    tests=("$INPUT_DIR/$extension/"*".$extension")
    tests=("${tests[@]%.$extension}") # remove extension
    tests=("${tests[@]##*/}") # remove leading path
}

function run_tests {
    type="$1"
    get_extension "$type"
    get_tests "$extension"
    for test in "${tests[@]}"; do
        run_test "$extension" "$type" "$test"
    done
}

# Use a command defined via FML evnironmental variable, or default to ./fml
fml=$(with_default "$FML" "./fml")
fml_ref_bc_int=$(with_default "$FML_REF_BC_INT" "$fml")
fml_parser=$(with_default "$FML_PARSER" "$fml")
ast_format=$(with_default "$AST_FORMAT" json)

which "$fml" 2>/dev/null 1>/dev/null # execute which just for the result
if (( $? != 0 ))
then
    echo "Cannot find interpreter at path: \"$fml\"." >&2
    echo "Provide a path to an FML interpreter via the environmental variable FML, eg:" >&2
    echo >&2
    echo "    export FML=/path/to/interpreter/fml" >&2
    echo "    ./suite $@" >&2
    echo >&2
    exit 1
fi

test_type=$1
shift

case "$test_type" in
show)
    get_tests "$1"
    printf '%s\n' "${tests[@]}"
    ;;
all)
    for suite in ast_interpret bc_interpret bc_compile; do
        run_tests "$suite"
    done
    ;;
*)
    # Verify test type and get extension ("bc" or "fml")
    get_extension "$test_type"

    for test in "$@"
    do
        run_test "$extension" "$test_type" "$test"
    done
    ;;
esac
